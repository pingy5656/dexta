--[[
   .---.  .---.          
  ( .-._)/ .-. )         
 (_) \   | | |(_)        
 _  \ \  | | | |         
( `-'  ) \ `-' /         
 `----'   )---'          
         (_)             
   .---.  .--.   ,'|"\   
  ( .-._)/ /\ \  | |\ \  
 (_) \  / /__\ \ | | \ \ 
 _  \ \ |  __  | | |  \ \
( `-'  )| |  |)| /(|`-' /
 `----' |_|  (_)(__)`--'                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      --]]SWEP.PrintName = "Electricity" SWEP.Author = "Dexter Barnes" SWEP.Contact = "Addon page" SWEP.Purpose = "I don't care if you don't like the hand effects." SWEP.Instructions = "Left click to zap crap." SWEP.Category = "Dexter's Plasmids" SWEP.Primary.Ammo = "None" SWEP.Primary.ClipSize = -1 SWEP.Primary.DefaultClip = -1 SWEP.Primary.Automatic = false SWEP.Secondary.Ammo = "None" SWEP.Secondary.Automatic = true SWEP.Secondary.ClipSize = -1 SWEP.Secondary.DefaultClip = -1 SWEP.UseHands = false SWEP.Base = "weapon_base" SWEP.Spawnable = true SWEP.ViewModelFOV = 56 SWEP.ViewModelFlip = false SWEP.HoldType = "magic" SWEP.ViewModel = "models/weapons/c_slam.mdl" SWEP.WorldModel = "models/weapons/c_bugbait.mdl" SWEP.Slot = 1 SWEP.SlotPos = 1 SWEP.SwayScale = 0 SWEP.BobScale = 0  function SWEP:Deploy() local vm = self.Owner:GetViewModel() vm:SendViewModelMatchingSequence(vm:LookupSequence("detonator_draw")) self:SetNextPrimaryFire(CurTime()+0.7) self:SetNextSecondaryFire(CurTime()+0.7) end  function SWEP:Initialize() self:SetHoldType(self.HoldType) end  function SWEP:Think() end  function SWEP:PreDrawViewModel(vm) render.SetBlend(0) end  function SWEP:PostDrawViewModel(vm) render.SetBlend(1) if ( !self.Arms ) then self.Arms = ClientsideModel("models/weapons/c_arms_citizen.mdl",RENDERGROUP_BOTH) self.Arms:SetNoDraw( true ) end self.Arms:SetModel(self.Owner:GetHands():GetModel()) self.Arms:SetPos(vm:GetPos()) self.Arms:SetAngles(vm:GetAngles()) self.Arms:SetParent(vm) self.Arms:AddEffects(EF_BONEMERGE) self.Arms:DrawModel() local BonesToLookZappy = { "ValveBiped.Bip01_L_Hand", "ValveBiped.Bip01_L_Finger4", "ValveBiped.Bip01_L_Finger41", "ValveBiped.Bip01_L_Finger42", "ValveBiped.Bip01_L_Finger3", "ValveBiped.Bip01_L_Finger31", "ValveBiped.Bip01_L_Finger32", "ValveBiped.Bip01_L_Finger2", "ValveBiped.Bip01_L_Finger21", "ValveBiped.Bip01_L_Finger22", "ValveBiped.Bip01_L_Finger1", "ValveBiped.Bip01_L_Finger11", "ValveBiped.Bip01_L_Finger12", "ValveBiped.Bip01_L_Finger0", "ValveBiped.Bip01_L_Finger01", "ValveBiped.Bip01_L_Finger02" } for k,v in pairs(BonesToLookZappy) do for k2,v2 in pairs(BonesToLookZappy) do render.SetMaterial(Material("trails/electric")) render.DrawBeam(vm:GetBoneMatrix(vm:LookupBone(v)):GetTranslation()+VectorRand():GetNormalized()*math.Rand(-0.5,0.5),vm:GetBoneMatrix(vm:LookupBone(v2)):GetTranslation()+VectorRand():GetNormalized()*math.Rand(-0.5,0.5),1,1,1,Color(255,255,255,255)) end end local BonesToLookZappy2 = { "ValveBiped.Bip01_R_Hand", "ValveBiped.Bip01_R_Finger4", "ValveBiped.Bip01_R_Finger41", "ValveBiped.Bip01_R_Finger42", "ValveBiped.Bip01_R_Finger3", "ValveBiped.Bip01_R_Finger31", "ValveBiped.Bip01_R_Finger32", "ValveBiped.Bip01_R_Finger2", "ValveBiped.Bip01_R_Finger21", "ValveBiped.Bip01_R_Finger22", "ValveBiped.Bip01_R_Finger1", "ValveBiped.Bip01_R_Finger11", "ValveBiped.Bip01_R_Finger12", "ValveBiped.Bip01_R_Finger0", "ValveBiped.Bip01_R_Finger01", "ValveBiped.Bip01_R_Finger02" } for k,v in pairs(BonesToLookZappy2) do for k2,v2 in pairs(BonesToLookZappy2) do render.SetMaterial(Material("trails/electric")) render.DrawBeam(vm:GetBoneMatrix(vm:LookupBone(v)):GetTranslation()+VectorRand():GetNormalized()*math.Rand(-0.5,0.5),vm:GetBoneMatrix(vm:LookupBone(v2)):GetTranslation()+VectorRand():GetNormalized()*math.Rand(-0.5,0.5),1,1,1,Color(255,255,255,255)) end end end  function SWEP:PrimaryAttack() local vm = self.Owner:GetViewModel() vm:SendViewModelMatchingSequence(vm:LookupSequence("stickwall_attach2")) local tr = util.TraceLine({ start = self.Owner:EyePos(), endpos = self.Owner:EyePos() + self.Owner:EyeAngles():Forward()*1000, filter = self.Owner }) if tr.Hit then if SERVER then local TeslaSpark = ents.Create("point_tesla") TeslaSpark:SetOwner(self.Owner) TeslaSpark:SetPos(tr.HitPos) TeslaSpark:Spawn() TeslaSpark:SetKeyValue("beamcount_max",15) TeslaSpark:SetKeyValue("beamcount_min",10) TeslaSpark:SetKeyValue("interval_max",0.5) TeslaSpark:SetKeyValue("interval_min",0.1) TeslaSpark:SetKeyValue("lifetime_max",0.5) TeslaSpark:SetKeyValue("lifetime_min",0.3) TeslaSpark:SetKeyValue("m_Color",255,255,255) TeslaSpark:SetKeyValue("m_flRadius",100) TeslaSpark:SetKeyValue("m_SoundName","DoSpark") TeslaSpark:SetKeyValue("texture","sprites/physcannon_bluelight1b.vmt") TeslaSpark:SetKeyValue("thick_max",5) TeslaSpark:SetKeyValue("thick_max",4) TeslaSpark:Fire("DoSpark","",0.01) TeslaSpark:Fire("DoSpark","",0.1) TeslaSpark:Fire("DoSpark","",0.2) TeslaSpark:Fire("DoSpark","",0.3) TeslaSpark:Fire("DoSpark","",0.4) TeslaSpark:Fire("kill","",1.0) end local fx = EffectData() fx:SetStart(tr.HitPos) fx:SetOrigin(self.Owner:GetBonePosition(self.Owner:LookupBone("ValveBiped.Bip01_R_Hand"))) if IsFirstTimePredicted() then util.Effect("ef_dex_plas_elecattack",fx) end self:EmitSound("ambient/explosions/explode_3.wav",90,math.random(97,103)) if IsFirstTimePredicted() then util.Decal("fadingscorch",tr.HitPos-tr.HitNormal,tr.HitPos+tr.HitNormal) end if SERVER then util.BlastDamage(self,self.Owner,tr.HitPos,100,50) end end self:SetNextPrimaryFire(CurTime()+1.1) self:SetNextSecondaryFire(CurTime()+1.1) end  function SWEP:SecondaryAttack() local vm = self.Owner:GetViewModel() vm:SendViewModelMatchingSequence(vm:LookupSequence("detonator_detonate")) local tr = util.TraceLine({ start = self.Owner:EyePos(), endpos = self.Owner:EyePos() + self.Owner:EyeAngles():Forward()*1000, filter = self.Owner }) if tr.Hit then local fx = EffectData() fx:SetStart(tr.HitPos) fx:SetOrigin(tr.HitPos) fx:SetAttachment(1) fx:SetEntity(self) if IsFirstTimePredicted() then util.Effect("ef_dex_plas_elecattack",fx) end self:EmitSound("ambient/energy/zap"..math.random(1,3)..".wav",90,math.random(97,103)) if IsFirstTimePredicted() then util.Decal("fadingscorch",tr.HitPos-tr.HitNormal,tr.HitPos+tr.HitNormal) end if SERVER then util.BlastDamage(self,self.Owner,tr.HitPos,50,10) end end self:SetNextPrimaryFire(CurTime()+0.1) self:SetNextSecondaryFire(CurTime()+0.1) end  function SWEP:Reload() end  function SWEP:DrawHUD() end  function SWEP:Holster(wep) return true end  function SWEP:DrawWorldModel() return false end  SWEP.OldEyeAng = Angle(0,0,0) SWEP.NewEyeAng = Angle(0,0,0) SWEP.WepBob = Vector(0,0,0) SWEP.HeightBob = 0  function DexLerpAng(sp,st,fi) fi.p = math.NormalizeAngle(fi.p-st.p) fi.y = math.NormalizeAngle(fi.y-st.y) fi.r = math.NormalizeAngle(fi.r-st.r) return st + fi*sp end  function SWEP:GetViewModelPosition(pos,ang) if self.Owner:OnGround() then self.WepBob = LerpVector(0.3,self.WepBob,Vector(math.sin(CurTime()*6)*math.Clamp((self.Owner:GetVelocity():Length()/600),-5,5),math.sin(CurTime()*12)*math.Clamp((self.Owner:GetVelocity():Length()/300),-5,5),math.sin(CurTime()*3)*math.Clamp((self.Owner:GetVelocity():Length()/600),-5,5))) else self.WepBob = LerpVector(0.2,self.WepBob,Vector(0,0,0)) end self.HeightBob = Lerp(0.1,self.HeightBob,math.Clamp(self.Owner:GetVelocity().z/30,-2,2)) pos = pos + Vector(0,0,self.HeightBob) pos = pos + ang:Up()*self.WepBob.x ang:RotateAroundAxis(ang:Right(),self.WepBob.y) ang:RotateAroundAxis(ang:Up(),self.WepBob.z) self.NewEyeAng = DexLerpAng(0.4,self.NewEyeAng,self.Owner:EyeAngles() - self.OldEyeAng) pos = pos + ang:Right()*self.NewEyeAng.y*0.05 pos = pos + ang:Up()*self.NewEyeAng.p*0.05 ang:RotateAroundAxis( ang:Up(),self.NewEyeAng.y*0.25) ang:RotateAroundAxis( ang:Right(),self.NewEyeAng.p*-0.25) self.OldEyeAng = self.Owner:EyeAngles() pos = pos + ang:Up()*math.sin(CurTime())/5 pos = pos + ang:Right()*math.sin(CurTime()/2)/5 ang:RotateAroundAxis(ang:Up(),math.sin(CurTime())/2.5) return pos, ang end--[[
 --]]